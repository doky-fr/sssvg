const SVGO = require('svgo');
const autocrop = require('svg-autocrop');
const svgson = require('svgson');
const svgPathParser = require('svg-path-parser');

function runSVGO(filePath, svg, floatPrecision = 3) {
    const svgo = new SVGO({
        multipass: true,
        floatPrecision: floatPrecision,
        plugins: [
            {
                removeViewBox: false
            },
            {
                convertPathData: {
                    forceAbsolutePath: true
                }
            },
            {
                convertShapeToPath: {
                    convertArcs: true
                }
            },
            {
                removeRasterImages: true
            },
            {
                removeScriptElement: true
            },
            {
                removeStyleElement: true
            },
            {
                removeDimensions: true
            },
            {
                removeOffCanvasPaths: true
            }
        ]
    });

    return svgo.optimize(svg, { path: filePath }).then((result) => result.data);
}

function parseViewBox(viewBoxStr) {
    if (!viewBoxStr || viewBoxStr.length === 0) {
        return undefined;
    }

    // Remove commas and plus signs, normalize and trim whitespace
    viewBoxStr = viewBoxStr.replace(/[,+]|px/g, ' ').replace(/\s+/g, ' ').replace(/^\s*|\s*$/g, '');

    const parts = viewBoxStr.split(' ');
    if (parts.length !== 4) {
        return undefined;
    }

    return {
        x: parseFloat(parts[0]),
        y: parseFloat(parts[1]),
        width: parseFloat(parts[2]),
        height: parseFloat(parts[3])
    };
}

/**
 * Convert a JSON representation  of a path (as generated by svg-path-parser) to a string.
 * The path data must use absolute coordinates
 */
function pathToString(d) {
    return d.map((command) => {
        if (command.command === 'moveto') {
            return `M ${command.x} ${command.y}`;
        } else if (command.command === 'lineto') {
            return `L ${command.x} ${command.y}`;
        } else if (command.command === 'horizontal lineto') {
            return `H ${command.x}`;
        } else if (command.command === 'vertical lineto') {
            return `V ${command.y}`;
        } else if (command.command === 'curveto') {
            return `C ${command.x1} ${command.y1} ${command.x2} ${command.y2} ${command.x} ${command.y}`;
        } else if (command.command === 'smooth curveto') {
            return `S ${command.x2} ${command.y2} ${command.x} ${command.y}`;
        } else if (command.command === 'quadratic curveto') {
            return `Q ${command.x1} ${command.y1} ${command.x} ${command.y}`;
        } else if (command.command === 'smooth quadratic curveto') {
            return `T ${command.x} ${command.y}`;
        } else if (command.command === 'elliptical arc') {
            return `A ${command.rx} ${command.ry} ${command.xAxisRotation} ${command.largeArc ? 1 : 0} ${command.sweep ? 1 : 0} ${command.x} ${command.y}`;
        } else if (command.command === 'closepath') {
            return 'Z';
        }
        return '';
    }).join(' ');
}

async function fixViewBox(svg, newViewBox) {
    let oldViewBox;

    // fix a value based on its axis
    const fix = (x, axis) => {
        if (axis === 'x') {
            return (x - oldViewBox.x) * newViewBox.width / oldViewBox.width + newViewBox.x;
        }
        return (x - oldViewBox.y) * newViewBox.height / oldViewBox.height + newViewBox.y;
    };
    const fixLength = (l, axis) => {
        if (axis === 'x') {
            return l * newViewBox.width / oldViewBox.width;
        }
        return l * newViewBox.height / oldViewBox.height;
    };

    // Convert to JSON AST
    const svgJSON = await svgson.parse(svg);
    oldViewBox = parseViewBox(svgJSON.attributes.viewBox);

    // Merge values from the old view box, if not specified in the new one
    if (newViewBox.x === undefined) {
        newViewBox.x = oldViewBox.x;
    }
    if (newViewBox.y === undefined) {
        newViewBox.y = oldViewBox.y;
    }
    if (newViewBox.width === undefined && newViewBox.height === undefined) {
        newViewBox.width = oldViewBox.width;
        newViewBox.height = oldViewBox.height;
    } else {
        // Compute width/height ratio, and apply it to the missing value
        const ratio = oldViewBox.width / oldViewBox.height;
        if (newViewBox.width === undefined && newViewBox.height !== undefined) {
            newViewBox.width = newViewBox.height * ratio;
        } else if (newViewBox.height === undefined && newViewBox.width !== undefined) {
            newViewBox.height = newViewBox.width / ratio;
        }
    }

    svgJSON.attributes.viewBox = `${newViewBox.x} ${newViewBox.y} ${newViewBox.width} ${newViewBox.height}`;

    const loopThrough = (ast) => {
        if (ast.type === 'element') {
            if (ast.name === 'path') {
                let d = svgPathParser.parseSVG(ast.attributes.d, {});
                svgPathParser.makeAbsolute(d);

                // Fix path data based on the new viewBbox
                for (let i = 0; i < d.length; i++) {
                    d[i].x0 = fix(d[i].x0, 'x');
                    d[i].y0 = fix(d[i].y0, 'y');
                    d[i].x = fix(d[i].x, 'x');
                    d[i].y = fix(d[i].y, 'y');

                    if (d[i].command === 'moveto'
                        || d[i].command === 'lineto'
                        || d[i].command === 'horizontal lineto'
                        || d[i].command === 'vertical lineto'
                        || d[i].command === 'closepath'
                        || d[i].command === 'smooth quadratic curveto') {
                        // Only have x0, y0, x, y
                    } else if (d[i].command === 'curveto') {
                        d[i].x1 = fix(d[i].x1, 'x');
                        d[i].y1 = fix(d[i].y1, 'y');
                        d[i].x2 = fix(d[i].x2, 'x');
                        d[i].y2 = fix(d[i].y2, 'y');
                    } else if (d[i].command === 'smooth curveto') {
                        d[i].x2 = fix(d[i].x2, 'x');
                        d[i].y2 = fix(d[i].y2, 'y');
                    } else if (d[i].command === 'quadratic curveto') {
                        d[i].x1 = fix(d[i].x1, 'x');
                        d[i].y1 = fix(d[i].y1, 'y');
                    } else if (d[i].command === 'elliptical arc') {
                        d[i].rx = fixLength(d[i].rx, 'x');
                        d[i].ry = fixLength(d[i].ry, 'y');
                    }
                }

                ast.attributes.d = pathToString(d);
            }
        }

        if (ast.children && ast.children.length > 0) {
            ast.children = ast.children.map(child => loopThrough(child));
        }

        return ast;
    };

    const modifiedSvg = loopThrough(svgJSON);
    return svgson.stringify(modifiedSvg);
}

async function optimizeSVG(filePath, svg, options) {
    const opts = {
        crop: false,
        viewBox: undefined,
        ...options
    };

    let result = await runSVGO(filePath, svg);

    if (opts.crop) {
        result = (await autocrop(result)).result;
        // Rerun svgo, just in case ^^
        result = await runSVGO(filePath, result);
    }

    if (opts.viewBox) {
        result = await fixViewBox(result, opts.viewBox);
        // Rerun svgo, just in case ^^
        result = await runSVGO(filePath, result, 2);
    }

    return result;
}

module.exports = {
    parseViewBox,
    optimizeSVG
};
